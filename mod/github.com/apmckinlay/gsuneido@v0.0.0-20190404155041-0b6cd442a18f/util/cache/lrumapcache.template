// this is a template
// it should be copied and K and V replaced

// LruMapCache is a cache with a crude approximation of LRU.
// Working set should fit in size.
// NOT thread safe.
type LruMapCache struct {
	old   map[K]V
	cur   map[K]V
	size  int
	fn    func(K) V
	nget  int
	nmiss int
}

func NewLruMapCache(size int, fn func(K) V) *LruMapCache {
	return &LruMapCache{cur: make(map[K]V, size),
		old: make(map[K]V), size: size, fn: fn}
}

func (c *LruMapCache) Get(key K) V {
	c.nget++
	val, ok := c.cur[key]
	if ok {
		return val
	}
	val, ok = c.old[key]
	if !ok {
		c.nmiss++
		val = c.fn(key)
	}
	if len(c.cur) >= c.size {
		c.old = c.cur
		c.cur = make(map[K]V, c.size)
	}
	c.cur[key] = val
	return val
}

func (c *LruMapCache) NGet() int {
	return c.nget
}

func (c *LruMapCache) NMiss() int {
	return c.nmiss
}
